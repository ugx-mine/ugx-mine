<script>
// === SUPABASE CONFIG ===
const SUPABASE_URL = 'https://rryvibgbpqyumfmgsiua.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJyeXZpYmdicHF5dW1mbWdzaXVhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY4OTUwNTUsImV4cCI6MjA4MjQ3MTA1NX0.IMqZtMEiPyMwb8AW1gyFao9Yz2qWgMDibfbpVWOeG8o';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// === LOCAL ADMIN CREDENTIALS (unchanged) ===
const ADMIN_USER = 'asutex2020';
const ADMIN_PASS = 'Asu12@ada24';

// === SUPABASE USER FUNCTIONS ===
async function saveUserToDB(username, userData) {
  const { error } = await supabase
    .from('users')
    .upsert({ username, ...userData }, { onConflict: 'username' });
  if (error) console.error('Supabase save error:', error);
}

async function getUserFromDB(username) {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('username', username)
    .single();
  if (error && error.code !== 'PGRST116') console.error('Fetch error:', error);
  return data;
}

async function getAllUsersFromDB() {
  const { data, error } = await supabase.from('users').select('*');
  if (error) {
    console.error('Fetch all users error:', error);
    return [];
  }
  return data || [];
}

// === APP STATE (same as before) ===
let appState = {
  isAuthenticated: false,
  currentUser: null,
  balance: 0,
  miningReward: 10000,
  miningCycleHours: 24,
  nextClaimTime: 0,
  pendingBoosterTxId: null,
  pendingBooster: null,
  transactions: [],
  userWallet: "",
  userEmail: "",
  userId: ""
};

// === DOM ELEMENTS (same as your original) ===
const authCard = document.getElementById('authCard');
const authToggle = document.getElementById('authToggle');
const adminPanelBtn = document.getElementById('adminPanelBtn');
const closeAuth = document.getElementById('closeAuth');
const signupForm = document.getElementById('signupForm');
const loginForm = document.getElementById('loginForm');
const tabSignup = document.getElementById('tabSignup');
const tabLogin = document.getElementById('tabLogin');
const mainContent = document.getElementById('mainContent');
const adminPanel = document.getElementById('adminPanel');
const backToMain = document.getElementById('backToMain');
const profileUserId = document.getElementById('profileUserId');
const profileUserName = document.getElementById('profileUserName');
const profileUserEmail = document.getElementById('profileUserEmail');
const editProfileBtn = document.getElementById('editProfileBtn');
const miningBtn = document.getElementById('miningBtn');
const miningDescription = document.getElementById('miningDescription');
const miningCountdown = document.getElementById('miningCountdown');
const withdrawBtn = document.getElementById('withdrawBtn');
const balanceUGX = document.getElementById('balanceUGX');
const balanceUSDT = document.getElementById('balanceUSDT');
const nextClaimAmount = document.getElementById('nextClaimAmount');
const claimCountdown = document.getElementById('claimCountdown');
const miningCycle = document.getElementById('miningCycle');
const miningRewardEl = document.getElementById('miningReward');
const transactionList = document.getElementById('transactionList');
const withdrawSuccessBanner = document.getElementById('withdrawSuccessBanner');
const withdrawModal = document.getElementById('withdrawModal');
const closeWithdraw = document.getElementById('closeWithdraw');
const copyWallet = document.getElementById('copyWallet');
const withdrawTxId = document.getElementById('withdrawTxId');
const confirmWithdraw = document.getElementById('confirmWithdraw');
const cancelWithdraw = document.getElementById('cancelWithdraw');
const withdrawAmountUGX = document.getElementById('withdrawAmountUGX');
const withdrawAmountUSDT = document.getElementById('withdrawAmountUSDT');
const withdrawFeeUGX = document.getElementById('withdrawFeeUGX');
const withdrawFeeUSDT = document.getElementById('withdrawFeeUSDT');
const userWalletSection = document.getElementById('userWalletSection');
const displayUserWallet = document.getElementById('displayUserWallet');
const paymentModal = document.getElementById('paymentModal');
const paymentTitle = document.getElementById('paymentTitle');
const closePayment = document.getElementById('closePayment');
const paymentWalletAddress = document.getElementById('paymentWalletAddress');
const transactionId = document.getElementById('transactionId');
const confirmPayment = document.getElementById('confirmPayment');
const cancelPayment = document.getElementById('cancelPayment');
const buyBooster1 = document.getElementById('buyBooster1');
const buyBooster2 = document.getElementById('buyBooster2');
const buyBooster3 = document.getElementById('buyBooster3');
const booster1CostUGX = document.getElementById('booster1CostUGX');
const booster1CostUSDT = document.getElementById('booster1CostUSDT');
const booster2CostUGX = document.getElementById('booster2CostUGX');
const booster2CostUSDT = document.getElementById('booster2CostUSDT');
const booster3CostUGX = document.getElementById('booster3CostUGX');
const booster3CostUSDT = document.getElementById('booster3CostUSDT');
const currentMiningInfo = document.getElementById('currentMiningInfo');
const newMiningInfo = document.getElementById('newMiningInfo');
const copyBoosterWallet = document.getElementById('copyBoosterWallet');
const editProfileModal = document.getElementById('editProfileModal');
const closeEditProfile = document.getElementById('closeEditProfile');
const userWalletInput = document.getElementById('userWalletInput');
const saveProfile = document.getElementById('saveProfile');
const cancelEditProfile = document.getElementById('cancelEditProfile');
const adminTotalUsers = document.getElementById('adminTotalUsers');
const adminTotalBalance = document.getElementById('adminTotalBalance');
const adminPendingRequests = document.getElementById('adminPendingRequests');
const adminActiveBoosters = document.getElementById('adminActiveBoosters');
const adminSearch = document.getElementById('adminSearch');
const adminFilter = document.getElementById('adminFilter');
const adminTxTableBody = document.getElementById('adminTxTableBody');
const adminUserTableBody = document.getElementById('adminUserTableBody');
const receiptModal = document.getElementById('receiptModal');
const closeReceipt = document.getElementById('closeReceipt');
const copyReceipt = document.getElementById('copyReceipt');
const printReceipt = document.getElementById('printReceipt');
const receiptContent = document.getElementById('receiptContent');

let balanceChart = null;
let txTypeChart = null;
let countdownInterval = null;

// === AUTH TABS ===
tabSignup.addEventListener('click', () => {
  tabSignup.classList.add('active');
  tabLogin.classList.remove('active');
  signupForm.classList.remove('hidden');
  loginForm.classList.add('hidden');
});
tabLogin.addEventListener('click', () => {
  tabLogin.classList.add('active');
  tabSignup.classList.remove('active');
  loginForm.classList.remove('hidden');
  signupForm.classList.add('hidden');
});

// === SIGN UP ===
signupForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  const username = document.getElementById('signupUsername').value.trim();
  const email = document.getElementById('signupEmail').value.trim();
  const password = document.getElementById('signupPassword').value;
  if (!username || !email || !password) {
    alert('All fields required');
    return;
  }
  const existing = await getUserFromDB(username);
  if (existing) {
    alert('Username already exists');
    return;
  }
  const newUser = {
    username,
    userEmail: email,
    password,
    balance: 0,
    miningReward: 10000,
    miningCycleHours: 24,
    nextClaimTime: null,
    pendingBoosterTxId: null,
    pendingBooster: null,
    transactions: [],
    userWallet: "",
    userId: `UGX-${Math.floor(100000 + Math.random() * 900000)}`
  };
  await saveUserToDB(username, newUser);
  login(username, password);
});

// === LOGIN ===
loginForm.addEventListener('submit', (e) => {
  e.preventDefault();
  const username = document.getElementById('loginUsername').value.trim();
  const password = document.getElementById('loginPassword').value;
  login(username, password);
});

async function login(username, password) {
  // Admin (local)
  if (username === ADMIN_USER && password === ADMIN_PASS) {
    appState = {
      isAuthenticated: true,
      currentUser: ADMIN_USER,
      balance: 0,
      miningReward: 10000,
      miningCycleHours: 24,
      nextClaimTime: 0,
      pendingBoosterTxId: null,
      pendingBooster: null,
      transactions: [],
      userWallet: "",
      userEmail: "admin@ugxmine.com",
      userId: "ADMIN"
    };
    afterLogin();
    return true;
  }

  // Regular user (Supabase)
  const user = await getUserFromDB(username);
  if (!user) {
    alert('User not found');
    return false;
  }
  if (user.password !== password) {
    alert('Incorrect password');
    return false;
  }

  appState = {
    isAuthenticated: true,
    currentUser: username,
    balance: parseFloat(user.balance) || 0,
    miningReward: parseFloat(user.mining_reward) || 10000,
    miningCycleHours: parseFloat(user.mining_cycle_hours) || 24,
    nextClaimTime: user.next_claim_time ? new Date(user.next_claim_time).getTime() : 0,
    pendingBoosterTxId: user.pending_booster_tx_id || null,
    pendingBooster: user.pending_booster ? parseFloat(user.pending_booster) : null,
    transactions: Array.isArray(user.transactions) ? user.transactions : [],
    userWallet: user.user_wallet || "",
    userEmail: user.user_email || "",
    userId: user.user_id || `UGX-${Math.floor(100000 + Math.random() * 900000)}`
  };

  // Show withdrawal banner if recently approved
  if (user.last_withdrawal_approved) {
    const lastApproved = new Date(user.last_withdrawal_approved).getTime();
    if (Date.now() - lastApproved < 60000) {
      setTimeout(() => {
        if (withdrawSuccessBanner) {
          withdrawSuccessBanner.classList.remove('hidden');
          setTimeout(() => withdrawSuccessBanner.classList.add('hidden'), 5000);
        }
      }, 500);
      // Clear the flag
      await saveUserToDB(username, { last_withdrawal_approved: null });
    }
  }

  afterLogin();
  return true;
}

function afterLogin() {
  authCard.classList.add('hidden');
  mainContent.classList.remove('hidden');
  localStorage.setItem('ugx_current_user', appState.currentUser); // for auto-login
  updateAuthButton();
  adminPanelBtn.classList.toggle('hidden', appState.currentUser !== ADMIN_USER);
  updateUI();
  if (appState.nextClaimTime > 0 && Date.now() < appState.nextClaimTime) {
    startCountdown();
  }
}

function updateAuthButton() {
  if (appState.isAuthenticated) {
    authToggle.textContent = 'Logout';
    authToggle.className = 'px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg';
  } else {
    authToggle.textContent = 'Sign Up / Login';
    authToggle.className = 'px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg';
  }
}

// === SAVE STATE TO SUPABASE ===
async function saveState() {
  if (appState.currentUser === ADMIN_USER) return;

  const user = {
    balance: appState.balance,
    mining_reward: appState.miningReward,
    mining_cycle_hours: appState.miningCycleHours,
    next_claim_time: appState.nextClaimTime ? new Date(appState.nextClaimTime).toISOString() : null,
    pending_booster_tx_id: appState.pendingBoosterTxId,
    pending_booster: appState.pendingBooster,
    transactions: appState.transactions,
    user_wallet: appState.userWallet,
    user_email: appState.userEmail,
    user_id: appState.userId
  };
  await saveUserToDB(appState.currentUser, user);
}

// === ALL YOUR EXISTING FUNCTIONS (unchanged logic) ===
// We'll keep your exact updateUI, formatUGX, toUSDT, claimReward, modals, admin panel, etc.
// Only difference: they call saveState() which now uses Supabase

function formatUGX(amount) {
  return new Intl.NumberFormat('en-UG', {
    style: 'currency',
    currency: 'UGX',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(amount).replace('UGX', '').trim();
}
function toUSDT(ugx) {
  return (ugx / 3700).toFixed(2);
}

function updateUI() {
  if (appState.isAuthenticated) {
    profileUserId.textContent = `User ID: ${appState.userId}`;
    profileUserName.textContent = appState.currentUser;
    profileUserEmail.textContent = appState.userEmail;
    userWalletInput.value = appState.userWallet || '';
  }
  balanceUGX.textContent = `${formatUGX(appState.balance)} UGX`;
  balanceUSDT.textContent = `(~${toUSDT(appState.balance)} USDT)`;
  nextClaimAmount.textContent = `${formatUGX(appState.miningReward)} UGX`;
  miningCycle.textContent = `${appState.miningCycleHours} hours`;
  miningRewardEl.textContent = `${formatUGX(appState.miningReward)} UGX per cycle`;

  // Booster costs
  const b1 = appState.balance * 2;
  const b2 = appState.balance * 4;
  const b3 = appState.balance * 8;
  booster1CostUGX.textContent = `${formatUGX(b1)} UGX`;
  booster1CostUSDT.textContent = `(~${toUSDT(b1)} USDT)`;
  booster2CostUGX.textContent = `${formatUGX(b2)} UGX`;
  booster2CostUSDT.textContent = `(~${toUSDT(b2)} USDT)`;
  booster3CostUGX.textContent = `${formatUGX(b3)} UGX`;
  booster3CostUSDT.textContent = `(~${toUSDT(b3)} USDT)`;

  // Countdown
  const now = Date.now();
  if (appState.nextClaimTime === 0 || now >= appState.nextClaimTime) {
    miningCountdown.textContent = 'Ready!';
    claimCountdown.textContent = 'Ready!';
    miningBtn.innerHTML = '<i class="fas fa-coins mr-2"></i> Claim Rewards';
    miningDescription.textContent = `Claim your ${formatUGX(appState.miningReward)} UGX reward`;
  } else {
    const d = appState.nextClaimTime - now;
    const h = Math.floor(d / (1000 * 60 * 60));
    const m = Math.floor((d % (1000 * 60 * 60)) / (1000 * 60));
    const s = Math.floor((d % (1000 * 60)) / 1000);
    const t = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    miningCountdown.textContent = t;
    claimCountdown.textContent = t;
    miningBtn.innerHTML = '<i class="fas fa-clock mr-2"></i> Mining...';
    miningDescription.textContent = `Next: +${formatUGX(appState.miningReward)} UGX`;
  }

  // Transactions
  if (appState.transactions.length === 0) {
    transactionList.innerHTML = '<div class="no-transactions">No transactions yet</div>';
  } else {
    let html = '';
    const sorted = [...appState.transactions].sort((a, b) => b.timestamp - a.timestamp);
    sorted.forEach(t => {
      html += `
      <div class="flex justify-between py-3 border-b border-gray-700">
        <div>
          <div class="font-bold">${t.type}</div>
          <div class="text-gray-400 text-sm">${t.description}</div>
        </div>
        <div class="text-right flex items-center gap-2">
          <div class="text-right">
            <div class="font-bold">${formatUGX(t.amount)} UGX</div>
            <div class="status-pending">${t.status}</div>
          </div>
          <button class="view-receipt-btn text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded" data-txid="${t.id}">
            View Receipt
          </button>
        </div>
      </div>
      `;
    });
    transactionList.innerHTML = html;
    document.querySelectorAll('.view-receipt-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const tx = appState.transactions.find(t => t.id === e.target.dataset.txid);
        showReceipt(tx);
      });
    });
  }
}

async function claimReward() {
  appState.balance += appState.miningReward;
  if (appState.pendingBoosterTxId) {
    const tx = appState.transactions.find(t => t.id === appState.pendingBoosterTxId);
    if (tx && tx.status === 'approved') {
      appState.miningCycleHours = appState.pendingBooster;
      appState.pendingBooster = null;
      appState.pendingBoosterTxId = null;
    }
  }
  const cycleMs = appState.miningCycleHours * 60 * 60 * 1000;
  appState.nextClaimTime = Date.now() + cycleMs;
  await saveState();
  updateUI();
  startCountdown();
  alert(`Claimed ${formatUGX(appState.miningReward)} UGX!`);
}

function startCountdown() {
  if (countdownInterval) clearInterval(countdownInterval);
  countdownInterval = setInterval(() => {
    const now = Date.now();
    const distance = appState.nextClaimTime - now;
    if (distance <= 0) {
      clearInterval(countdownInterval);
      miningCountdown.textContent = 'Ready!';
      claimCountdown.textContent = 'Ready!';
      miningBtn.innerHTML = '<i class="fas fa-coins mr-2"></i> Claim Rewards';
      miningDescription.textContent = `Claim your ${formatUGX(appState.miningReward)} UGX reward`;
      return;
    }
    const h = Math.floor(distance / (1000 * 60 * 60));
    const m = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
    const s = Math.floor((distance % (1000 * 60)) / 1000);
    const timeStr = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    miningCountdown.textContent = timeStr;
    claimCountdown.textContent = timeStr;
  }, 1000);
}

// === MODAL HANDLERS (same as before, but async save) ===
authToggle.addEventListener('click', () => {
  if (appState.isAuthenticated) {
    appState.isAuthenticated = false;
    appState.currentUser = null;
    localStorage.removeItem('ugx_current_user');
    mainContent.classList.add('hidden');
    adminPanel.classList.add('hidden');
    authCard.classList.add('hidden');
    updateAuthButton();
  } else {
    authCard.classList.remove('hidden');
  }
});

closeAuth.addEventListener('click', () => authCard.classList.add('hidden'));

miningBtn.addEventListener('click', () => {
  if (appState.nextClaimTime === 0 || Date.now() >= appState.nextClaimTime) {
    claimReward();
  }
});

withdrawBtn.addEventListener('click', () => {
  if (!appState.userWallet) {
    alert('Please set your withdrawal wallet address in Edit Profile first!');
    return;
  }
  const fee = Math.floor(appState.balance * 0.2);
  withdrawAmountUGX.textContent = `${formatUGX(appState.balance)} UGX`;
  withdrawAmountUSDT.textContent = `(~${toUSDT(appState.balance)} USDT)`;
  withdrawFeeUGX.textContent = `${formatUGX(fee)} UGX`;
  withdrawFeeUSDT.textContent = `(~${toUSDT(fee)} USDT)`;
  userWalletSection.classList.remove('hidden');
  displayUserWallet.textContent = appState.userWallet;
  withdrawTxId.value = '';
  withdrawModal.classList.remove('hidden');
});

closeWithdraw.addEventListener('click', () => withdrawModal.classList.add('hidden'));
cancelWithdraw.addEventListener('click', () => withdrawModal.classList.add('hidden'));

confirmWithdraw.addEventListener('click', async () => {
  const txId = withdrawTxId.value.trim();
  if (!txId) {
    alert('Please enter a transaction ID for the fee payment.');
    return;
  }
  const fee = Math.floor(appState.balance * 0.2);
  appState.transactions.push({
    id: 'TXN-' + Date.now(),
    type: 'Withdrawal Request',
    description: `Fee payment TxID: ${txId}. Full balance: ${formatUGX(appState.balance)} UGX`,
    amount: appState.balance,
    fee: fee,
    status: 'pending',
    timestamp: Date.now(),
    wallet: appState.userWallet
  });
  await saveState();
  updateUI();
  withdrawModal.classList.add('hidden');
  alert('Withdrawal request submitted for admin approval!');
});

// Booster handlers
buyBooster1.addEventListener('click', () => showPaymentModal(1, 8));
buyBooster2.addEventListener('click', () => showPaymentModal(2, 6));
buyBooster3.addEventListener('click', () => showPaymentModal(3, 4));

function showPaymentModal(boosterType, duration) {
  const names = {1: "Speed Booster", 2: "Power Booster", 3: "Quantum Booster"};
  paymentTitle.textContent = `${names[boosterType]} Payment`;
  currentMiningInfo.textContent = `${appState.miningCycleHours} hours → ${formatUGX(appState.miningReward)} UGX/cycle`;
  newMiningInfo.textContent = `${duration} hours → ${formatUGX(appState.miningReward)} UGX/cycle`;
  transactionId.value = '';
  paymentModal.dataset.boosterType = boosterType;
  paymentModal.dataset.duration = duration;
  paymentModal.classList.remove('hidden');
}

closePayment.addEventListener('click', () => paymentModal.classList.add('hidden'));
cancelPayment.addEventListener('click', () => paymentModal.classList.add('hidden'));

confirmPayment.addEventListener('click', async () => {
  const txId = transactionId.value.trim();
  if (!txId) {
    alert('Please enter a transaction ID');
    return;
  }
  const boosterType = parseInt(paymentModal.dataset.boosterType);
  const duration = parseInt(paymentModal.dataset.duration);
  const multipliers = {1: 2, 2: 4, 3: 8};
  const cost = appState.balance * multipliers[boosterType];
  const newTxId = 'TXN-' + Date.now();
  appState.transactions.push({
    id: newTxId,
    type: 'Booster Payment',
    description: `Payment for booster (TxID: ${txId})`,
    amount: cost,
    status: 'pending',
    timestamp: Date.now(),
    duration: duration
  });
  appState.pendingBoosterTxId = newTxId;
  appState.pendingBooster = duration;
  await saveState();
  updateUI();
  paymentModal.classList.add('hidden');
  alert('Payment submitted for admin approval!');
});

// Copy wallet
copyWallet.addEventListener('click', () => {
  navigator.clipboard.writeText('TX3CWq6CPLpJdPeSsEDdY5vjGyYF5f1Csg').then(() => {
    const original = copyWallet.textContent;
    copyWallet.textContent = 'Copied!';
    setTimeout(() => copyWallet.textContent = original, 1500);
  });
});
copyBoosterWallet.addEventListener('click', () => {
  navigator.clipboard.writeText('TX3CWq6CPLpJdPeSsEDdY5vjGyYF5f1Csg').then(() => {
    const original = copyBoosterWallet.textContent;
    copyBoosterWallet.textContent = 'Copied!';
    setTimeout(() => copyBoosterWallet.textContent = original, 1500);
  });
});

// Edit profile
editProfileBtn.addEventListener('click', () => {
  userWalletInput.value = appState.userWallet || '';
  editProfileModal.classList.remove('hidden');
});
closeEditProfile.addEventListener('click', () => editProfileModal.classList.add('hidden'));
cancelEditProfile.addEventListener('click', () => editProfileModal.classList.add('hidden'));
saveProfile.addEventListener('click', async () => {
  const wallet = userWalletInput.value.trim();
  if (wallet && !wallet.startsWith('T')) {
    alert('Please enter a valid TRC20 (USDT) or UGX wallet address starting with "T"');
    return;
  }
  appState.userWallet = wallet;
  await saveState();
  updateUI();
  editProfileModal.classList.add('hidden');
  alert('Profile updated successfully!');
});

// Receipt
function showReceipt(tx) {
  let receiptText = `===============================
UGX MINING PLATFORM
Transaction Receipt
===============================
Transaction ID: ${tx.id}
Type: ${tx.type}
Status: ${tx.status}
Amount: ${formatUGX(tx.amount)} UGX
Date: ${new Date(tx.timestamp).toLocaleString()}
`;
  if (tx.type === 'Withdrawal Request') {
    receiptText += `Wallet: ${appState.userWallet || 'Not set'}\n`;
    receiptText += `Note: Funds will be sent to this wallet.\n`;
  } else if (tx.type === 'Booster Payment') {
    receiptText += `Cycle: ${tx.duration} hours\n`;
  }
  receiptText += `\nThank you for using UGX Mine!`;
  receiptContent.textContent = receiptText;
  receiptModal.classList.remove('hidden');
}
copyReceipt.addEventListener('click', () => {
  navigator.clipboard.writeText(receiptContent.textContent).then(() => {
    const original = copyReceipt.innerHTML;
    copyReceipt.innerHTML = '<i class="fas fa-check mr-2"></i> Copied!';
    setTimeout(() => copyReceipt.innerHTML = '<i class="fas fa-copy mr-2"></i> Copy', 2000);
  });
});
printReceipt.addEventListener('click', () => {
  const w = window.open('', '', 'height=400,width=600');
  w.document.write('<html><head><title>Receipt</title><style>body{font-family:monospace;padding:20px;}</style></head><body><pre>' + receiptContent.textContent + '</pre></body></html>');
  w.document.close();
  w.print();
});
closeReceipt.addEventListener('click', () => receiptModal.classList.add('hidden'));
receiptModal.addEventListener('click', (e) => {
  if (e.target === receiptModal) receiptModal.classList.add('hidden');
});

// === ADMIN PANEL (fetches from Supabase) ===
adminPanelBtn.addEventListener('click', () => {
  mainContent.classList.add('hidden');
  adminPanel.classList.remove('hidden');
  loadAdminPanel();
});
backToMain.addEventListener('click', () => {
  adminPanel.classList.add('hidden');
  mainContent.classList.remove('hidden');
});

async function loadAdminPanel() {
  const users = await getAllUsersFromDB();
  let allTx = [];
  users.forEach(user => {
    const txs = Array.isArray(user.transactions) ? user.transactions : [];
    txs.forEach(tx => allTx.push({ ...tx, username: user.username }));
  });
  const pendingTx = allTx.filter(tx => tx.status === 'pending');

  adminTotalUsers.textContent = users.length;
  const totalBalance = users.reduce((sum, u) => sum + (parseFloat(u.balance) || 0), 0);
  adminTotalBalance.textContent = `${formatUGX(totalBalance)} UGX`;
  adminPendingRequests.textContent = pendingTx.length;
  const activeBoosters = users.filter(u =>
    u.pending_booster_tx_id &&
    Array.isArray(u.transactions) &&
    u.transactions.find(t => t.id === u.pending_booster_tx_id)?.status === 'approved'
  ).length;
  adminActiveBoosters.textContent = activeBoosters;

  renderTransactionTable(allTx);
  renderUserTable(users);
  renderBalanceChart(users);
  renderTxTypeChart(allTx);
}

// Include your existing renderTransactionTable, renderUserTable, renderBalanceChart, renderTxTypeChart, approveRequest, rejectRequest
// (They work the same — just replace getAllUsers() with getAllUsersFromDB() and use Supabase save)

async function approveRequest(username, txId) {
  const user = await getUserFromDB(username);
  if (!user || !Array.isArray(user.transactions)) return;
  const tx = user.transactions.find(t => t.id === txId);
  if (!tx) return;

  const updatedTxs = user.transactions.map(t =>
    t.id === txId ? { ...t, status: 'approved' } : t
  );

  let updateData = { transactions: updatedTxs };

  if (tx.type === 'Withdrawal Request') {
    updateData = {
      ...updateData,
      balance: 0,
      mining_cycle_hours: 24,
      pending_booster: null,
      pending_booster_tx_id: null,
      next_claim_time: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
      last_withdrawal_approved: new Date().toISOString()
    };
    alert(`Withdrawal approved for ${username}. Balance reset.`);
  } else if (tx.type === 'Booster Payment') {
    alert(`Booster approved for ${username}.`);
  }

  await saveUserToDB(username, updateData);

  if (appState.currentUser === username) {
    login(username, user.password);
  }

  loadAdminPanel();
}

async function rejectRequest(username, txId) {
  const user = await getUserFromDB(username);
  if (!user || !Array.isArray(user.transactions)) return;
  const updatedTxs = user.transactions.map(tx =>
    tx.id === txId ? { ...tx, status: 'rejected' } : tx
  );
  await saveUserToDB(username, { transactions: updatedTxs });
  if (appState.currentUser === username) {
    login(username, user.password);
  }
  alert(`Rejected request for ${username}`);
  loadAdminPanel();
}

// Reuse your existing render functions (they work as-is)

function renderTransactionTable(transactions) {
  const searchTerm = adminSearch.value.toLowerCase();
  const filterType = adminFilter.value;
  let filtered = transactions.filter(tx => {
    const matchesSearch =
      tx.username.toLowerCase().includes(searchTerm) ||
      (tx.id && tx.id.toLowerCase().includes(searchTerm));
    const matchesType = filterType === 'all' || tx.type === filterType;
    return matchesSearch && matchesType;
  });
  if (filtered.length === 0) {
    adminTxTableBody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-gray-500">No transactions found</td></tr>';
    return;
  }
  let html = '';
  filtered.sort((a, b) => b.timestamp - a.timestamp);
  filtered.forEach(tx => {
    const wallet = 'Not set'; // you could fetch per user if needed
    const date = new Date(tx.timestamp).toLocaleString();
    const statusClass =
      tx.status === 'approved' ? 'text-green-400' :
      tx.status === 'rejected' ? 'text-red-400' : 'text-yellow-400';
    html += `
    <tr class="border-b border-gray-800 hover:bg-gray-800/50">
      <td class="py-2 font-mono">${tx.username}</td>
      <td class="py-2 font-mono text-xs">${wallet}</td>
      <td class="py-2">${tx.type}</td>
      <td class="py-2">${formatUGX(tx.amount)} UGX</td>
      <td class="py-2"><span class="${statusClass}">${tx.status}</span></td>
      <td class="py-2 text-xs">${date}</td>
      <td class="py-2">
    `;
    if (tx.status === 'pending') {
      html += `
        <button class="bg-green-600 hover:bg-green-700 text-xs px-2 py-1 rounded mr-1 approve-btn"
          data-username="${tx.username}" data-txid="${tx.id}">Approve</button>
        <button class="bg-red-600 hover:bg-red-700 text-xs px-2 py-1 rounded reject-btn"
          data-username="${tx.username}" data-txid="${tx.id}">Reject</button>
      `;
    } else {
      html += `<span class="text-gray-500">—</span>`;
    }
    html += `</td></tr>`;
  });
  adminTxTableBody.innerHTML = html;
  document.querySelectorAll('.approve-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      approveRequest(e.target.dataset.username, e.target.dataset.txid);
    });
  });
  document.querySelectorAll('.reject-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      rejectRequest(e.target.dataset.username, e.target.dataset.txid);
    });
  });
}

function renderUserTable(users) {
  if (users.length === 0) {
    adminUserTableBody.innerHTML = '<tr><td colspan="5" class="text-center py-4 text-gray-500">No users</td></tr>';
    return;
  }
  let html = '';
  users.forEach(user => {
    const cycle = user.mining_cycle_hours || 24;
    html += `
    <tr class="border-b border-gray-800 hover:bg-gray-800/50">
      <td class="py-2 font-mono">${user.username}</td>
      <td class="py-2">${user.user_email || '—'}</td>
      <td class="py-2">${formatUGX(user.balance || 0)} UGX</td>
      <td class="py-2 font-mono text-xs">${user.user_wallet || 'Not set'}</td>
      <td class="py-2">${cycle}h</td>
    </tr>
    `;
  });
  adminUserTableBody.innerHTML = html;
}

function renderBalanceChart(users) {
  const ctx = document.getElementById('balanceChart').getContext('2d');
  if (balanceChart) balanceChart.destroy();
  const topUsers = users
    .sort((a, b) => (b.balance || 0) - (a.balance || 0))
    .slice(0, 10);
  balanceChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: topUsers.map(u => u.username),
      datasets: [{
        label: 'Balance (UGX)',
        data: topUsers.map(u => u.balance || 0),
        backgroundColor: 'rgba(0, 193, 106, 0.7)',
        borderColor: 'rgba(0, 193, 106, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      plugins: { legend: { display: false } },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            color: '#94a3b8',
            callback: (value) => formatUGX(value)
          }
        },
        x: { ticks: { color: '#94a3b8' } }
      }
    }
  });
}

function renderTxTypeChart(transactions) {
  const ctx = document.getElementById('txTypeChart').getContext('2d');
  if (txTypeChart) txTypeChart.destroy();
  const typeCounts = transactions.reduce((acc, tx) => {
    acc[tx.type] = (acc[tx.type] || 0) + 1;
    return acc;
  }, {});
  const labels = Object.keys(typeCounts);
  const data = Object.values(typeCounts);
  txTypeChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        data: data,
        backgroundColor: [
          'rgba(0, 193, 106, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(96, 165, 250, 0.8)'
        ],
        borderWidth: 2,
        borderColor: '#0f172a'
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: { labels: { color: '#e2e8f0' } }
      }
    }
  });
}

adminSearch.addEventListener('input', () => loadAdminPanel());
adminFilter.addEventListener('change', () => loadAdminPanel());

// === INIT ===
async function initApp() {
  const savedUser = localStorage.getItem('ugx_current_user');
  if (savedUser) {
    const user = await getUserFromDB(savedUser);
    if (user) {
      login(savedUser, user.password);
      return;
    }
  }
  authCard.classList.remove('hidden');
  updateAuthButton();
}

document.addEventListener('DOMContentLoaded', initApp);
</script>
