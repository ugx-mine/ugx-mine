<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>UGX Mining Platform</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- SUPABASE CLIENT -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
/* [Your existing CSS stays exactly the same — omitted here for brevity but included in full file] */
.mining-card {
background: linear-gradient(135deg, #0f172a 0%, #121a2e 100%);
border: 1px solid #2a3d6a;
border-radius: 16px;
padding: 1.5rem;
margin-bottom: 1.5rem;
}
/* ... [rest of your CSS] ... */
</style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen font-sans">
<!-- [Your entire HTML structure remains identical — omitted here for brevity] -->
<div class="container mx-auto px-4 py-6">
  <!-- Header, Auth Card, Main Content, Admin Panel, Modals — all exactly as before -->
</div>

<!-- SUPABASE INITIALIZATION & LOGIC -->
<script>
// === SUPABASE CONFIG ===
const SUPABASE_URL = 'https://rryvibgbpqyumfmgsiua.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJyeXZpYmdicHF5dW1mbWdzaXVhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY4OTUwNTUsImV4cCI6MjA4MjQ3MTA1NX0.IMqZtMEiPyMwb8AW1gyFao9Yz2qWgMDibfbpVWOeG8o';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// === ADMIN CREDENTIALS (still local for simplicity) ===
const ADMIN_USER = 'asutex2020';
const ADMIN_PASS = 'Asu12@ada24';

// === SUPABASE USER STORAGE FUNCTIONS ===
async function saveUserToDB(userData) {
  const { error } = await supabase
    .from('users')
    .upsert(userData, { onConflict: 'username' });
  if (error) {
    console.error('Save error:', error);
    alert('Failed to save user data. Check console.');
  }
}

async function getUserFromDB(username) {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .eq('username', username)
    .single();
  if (error && error.code !== 'PGRST116') {
    console.error('Fetch error:', error);
    alert('Failed to fetch user. Check network/console.');
  }
  return data;
}

async function getAllUsersFromDB() {
  const { data, error } = await supabase.from('users').select('*');
  if (error) {
    console.error('Fetch all users error:', error);
    return [];
  }
  return data;
}

// === APP STATE (same structure as before) ===
let appState = {
  isAuthenticated: false,
  currentUser: null,
  balance: 0,
  miningReward: 10000,
  miningCycleHours: 24,
  nextClaimTime: 0,
  pendingBoosterTxId: null,
  pendingBooster: null,
  transactions: [],
  userWallet: "",
  userEmail: "",
  userId: ""
};

// [All your DOM element references — identical to original]

let countdownInterval = null;

// === LOGIN WITH SUPABASE ===
async function login(username, password) {
  // Admin check (local)
  if (username === ADMIN_USER && password === ADMIN_PASS) {
    appState = {
      isAuthenticated: true,
      currentUser: ADMIN_USER,
      balance: 0,
      miningReward: 10000,
      miningCycleHours: 24,
      nextClaimTime: 0,
      pendingBoosterTxId: null,
      pendingBooster: null,
      transactions: [],
      userWallet: "",
      userEmail: "admin@ugxmine.com",
      userId: "ADMIN"
    };
    afterLogin();
    return true;
  }

  // Fetch user from Supabase
  const user = await getUserFromDB(username);
  if (!user) {
    alert('User not found');
    return false;
  }
  if (user.password !== password) {
    alert('Incorrect password');
    return false;
  }

  // Load user into appState
  appState = {
    isAuthenticated: true,
    currentUser: username,
    balance: user.balance || 0,
    miningReward: user.miningReward || 10000,
    miningCycleHours: user.mining_cycle_hours || 24,
    nextClaimTime: user.next_claim_time ? new Date(user.next_claim_time).getTime() : 0,
    pendingBoosterTxId: user.pending_booster_tx_id || null,
    pendingBooster: user.pending_booster || null,
    transactions: user.transactions || [],
    userWallet: user.user_wallet || "",
    userEmail: user.user_email || "",
    userId: user.user_id || `UGX-${Math.floor(100000 + Math.random() * 900000)}`
  };

  // Show withdrawal banner if recently approved
  if (user.last_withdrawal_approved && (Date.now() - new Date(user.last_withdrawal_approved).getTime() < 60000)) {
    setTimeout(() => {
      const banner = document.getElementById('withdrawSuccessBanner');
      if (banner) {
        banner.classList.remove('hidden');
        setTimeout(() => banner.classList.add('hidden'), 5000);
      }
    }, 500);
    // Clear the flag in DB
    await saveUserToDB({ username, last_withdrawal_approved: null });
  }

  afterLogin();
  return true;
}

// === SAVE STATE TO SUPABASE ===
async function saveStateToDB() {
  if (appState.currentUser === ADMIN_USER) return;

  const user = {
    username: appState.currentUser,
    balance: appState.balance,
    mining_cycle_hours: appState.miningCycleHours,
    next_claim_time: appState.nextClaimTime ? new Date(appState.nextClaimTime).toISOString() : null,
    pending_booster_tx_id: appState.pendingBoosterTxId,
    pending_booster: appState.pendingBooster,
    transactions: appState.transactions,
    user_wallet: appState.userWallet,
    user_id: appState.userId,
    user_email: appState.userEmail // ensure email is saved
  };
  await saveUserToDB(user);
}

// === INIT ===
async function initApp() {
  const savedUser = localStorage.getItem('ugx_current_user');
  if (savedUser) {
    const user = await getUserFromDB(savedUser);
    if (user) {
      // Attempt silent login using stored password (for demo only!)
      if (login(savedUser, user.password)) return;
    }
  }
  document.getElementById('authCard').classList.remove('hidden');
  updateAuthButton();
}

// === AFTER LOGIN (same as before) ===
function afterLogin() {
  document.getElementById('authCard').classList.add('hidden');
  document.getElementById('mainContent').classList.remove('hidden');
  localStorage.setItem('ugx_current_user', appState.currentUser);
  updateAuthButton();
  document.getElementById('adminPanelBtn').classList.toggle('hidden', appState.currentUser !== ADMIN_USER);
  updateUI();
  if (appState.nextClaimTime > 0 && Date.now() < appState.nextClaimTime) {
    startCountdown();
  }
}

// [All your UI update, countdown, claim, modal, and admin functions — identical logic]

// === OVERRIDE CLAIM TO SAVE TO DB ===
function claimReward() {
  appState.balance += appState.miningReward;
  if (appState.pendingBoosterTxId) {
    const tx = appState.transactions.find(t => t.id === appState.pendingBoosterTxId);
    if (tx && tx.status === 'approved') {
      appState.miningCycleHours = appState.pendingBooster;
      appState.pendingBooster = null;
      appState.pendingBoosterTxId = null;
    }
  }
  const cycleMs = appState.miningCycleHours * 60 * 60 * 1000;
  appState.nextClaimTime = Date.now() + cycleMs;
  saveStateToDB(); // ← Now saves to Supabase
  updateUI();
  startCountdown();
  alert(`Claimed ${formatUGX(appState.miningReward)} UGX!`);
}

// === OVERRIDE MODAL HANDLERS TO SAVE TO DB ===
// Example: confirmWithdraw
document.getElementById('confirmWithdraw').addEventListener('click', async () => {
  const txId = document.getElementById('withdrawTxId').value.trim();
  if (!txId) {
    alert('Please enter a transaction ID for the fee payment.');
    return;
  }
  const fee = Math.floor(appState.balance * 0.2);
  appState.transactions.push({
    id: 'TXN-' + Date.now(),
    type: 'Withdrawal Request',
    description: `Fee payment TxID: ${txId}. Full balance: ${formatUGX(appState.balance)} UGX`,
    amount: appState.balance,
    fee: fee,
    status: 'pending',
    timestamp: Date.now(),
    wallet: appState.userWallet
  });
  await saveStateToDB(); // ← Save to Supabase
  updateUI();
  document.getElementById('withdrawModal').classList.add('hidden');
  alert('Withdrawal request submitted for admin approval!');
});

// Similarly, update booster payment handlers to call saveStateToDB()

// === ENHANCED ADMIN PANEL (FETCH FROM SUPABASE) ===
async function loadAdminPanel() {
  const users = await getAllUsersFromDB();
  const allTransactions = users.flatMap(user =>
    (user.transactions || []).map(tx => ({ ...tx, username: user.username }))
  );
  const pendingTx = allTransactions.filter(tx => tx.status === 'pending');
  
  // [Rest of your admin stats/table/chart logic — unchanged]

  // Override approveRequest to update Supabase
  window.approveRequest = async (username, txId) => {
    const user = await getUserFromDB(username);
    if (!user) return;
    const txIndex = user.transactions.findIndex(t => t.id === txId);
    if (txIndex === -1) return;
    
    const updatedTxs = [...user.transactions];
    updatedTxs[txIndex] = { ...updatedTxs[txIndex], status: 'approved' };
    
    let updateData = { transactions: updatedTxs };
    
    if (updatedTxs[txIndex].type === 'Withdrawal Request') {
      updateData = {
        ...updateData,
        balance: 0,
        mining_cycle_hours: 24,
        pending_booster: null,
        pending_booster_tx_id: null,
        next_claim_time: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
        last_withdrawal_approved: new Date().toISOString()
      };
    }
    
    await saveUserToDB({ username, ...updateData });
    alert(`Approved ${updatedTxs[txIndex].type} for ${username}`);
    loadAdminPanel();
  };

  window.rejectRequest = async (username, txId) => {
    const user = await getUserFromDB(username);
    if (!user) return;
    const updatedTxs = user.transactions.map(tx =>
      tx.id === txId ? { ...tx, status: 'rejected' } : tx
    );
    await saveUserToDB({ username, transactions: updatedTxs });
    alert(`Rejected request for ${username}`);
    loadAdminPanel();
  };
}

// [All other functions (formatUGX, toUSDT, modals, etc.) remain identical]

// Initialize on load
document.addEventListener('DOMContentLoaded', initApp);
</script>
</body>
</html>
